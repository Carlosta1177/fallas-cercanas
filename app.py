import streamlit as st
import pandas as pd
from geopy.distance import geodesic
from opencage.geocoder import OpenCageGeocode
import folium
from streamlit_folium import st_folium
import openrouteservice

# Function to find the nearest falla
def nearest_falla(data, user_location):
    data['distance'] = data.apply(lambda row: geodesic(user_location, (row['geo_point_2d_lat'], row['geo_point_2d_lon'])).km, axis=1)
    closest_falla = data.loc[data['distance'].idxmin()]
    return closest_falla

# Function to load and process data, standardizing column names
def load_data(path, falla_type, rename_columns):
    data = pd.read_csv(path, delimiter=';')
    data[['geo_point_2d_lat', 'geo_point_2d_lon']] = data['geo_point_2d'].str.split(',', expand=True).astype(float)
    data['Falla Type'] = falla_type
    data.rename(columns=rename_columns, inplace=True)
    return data

# Dictionaries to rename columns
rename_columns_adultas = {
    'Esbós / Lema': 'Esbos',
    'Anyo Fundació / Año Fundacion': 'Any_Fundacio'
}
rename_columns_infantiles = {
    'Esbós / Boceto': 'Esbos',
    'Any Fundació / Año Fundacion': 'Any_Fundacio'
}

# Load the data
data_fallas_adultas = load_data("falles-fallas.csv", 'Adult Falla', rename_columns_adultas)
data_fallas_infantiles = load_data("falles-infantils-fallas-infantiles.csv", 'Child Falla', rename_columns_infantiles)
data_carpas_falleras = load_data("carpes-falles-carpas-fallas.csv", 'Falla Tent', {})

# Concatenate adult and child fallas to get names of tent fallas
data_fallas = pd.concat([data_fallas_adultas, data_fallas_infantiles], ignore_index=True)

# Add names of fallas to falla tents
data_carpas_falleras = data_carpas_falleras.merge(data_fallas_adultas[['Id. Falla', 'Nom / Nombre']], on='Id. Falla', how='left')

# Combine all data sets
data = pd.concat([data_fallas_adultas, data_fallas_infantiles, data_carpas_falleras], ignore_index=True)

# Function to calculate tourist route by accumulating distances
def calculate_tourist_route(data, user_location, max_distance, ors_client):
    data['distance'] = data.apply(lambda row: geodesic(user_location, (row['geo_point_2d_lat'], row['geo_point_2d_lon'])).km, axis=1)
    nearby_fallas = data.sort_values(by='distance')
    
    route = []
    accumulated_distance = 0.0
    current_location = user_location

    for _, falla in nearby_fallas.iterrows():
        distance_to_falla = geodesic(current_location, (falla['geo_point_2d_lat'], falla['geo_point_2d_lon'])).km
        if accumulated_distance + distance_to_falla > max_distance:
            break
        accumulated_distance += distance_to_falla
        falla['accumulated_distance'] = accumulated_distance
        route.append(falla)
        current_location = (falla['geo_point_2d_lat'], falla['geo_point_2d_lon'])
        
    if not route:
        st.write("No available routes of this type.")
        return pd.DataFrame()  # Return an empty DataFrame
        
    return pd.DataFrame(route)

# Function to get route with real streets using OpenRouteService
def get_route_with_streets(coordinates, ors_client):
    route = ors_client.directions(
        coordinates=coordenadas,
        profile='foot-walking',
        format='geojson'
    )
    return route

# Custom styles
st.markdown("""
    <style>
        .main {
            background-color: #FFF38E;
            color: #333;
            font-family: 'Arial', sans-serif;
        }
        h1, h2, h3 {
            text-align: center;
            color: #D14524;
        }
        .stButton button {
            background-color: #D14524;
            color: white !important;
            border-radius: 10px;
        }
        .stButton button:hover {
            background-color: #FF6100;
            color: white !important;
        }
        .stSelectbox div[data-baseweb='select'] {
            background-color: #B3E5FC;
            border-radius: 5px;
            color: #D14524 !important;
        }
        .stSidebar .sidebar-content {
            background-color: #B3E5FC !important;
            color: #D14524;
        }
        .sidebar .sidebar-content {
            background-color: #B3E5FC;
        }
        /* Styles for all texts generated by Streamlit */
        .stTextInput > label, .stTextArea > label, .stNumberInput > label, .stSelectbox > label, .stRadio > label, .stCheckbox > label, .stSlider > label, .stButton, .stMarkdown, .stDataFrame, .stTable, .stColorPicker > label, .stDateInput > label, .stFileUploader > label, .stJson, .stImage, .stVideo, .stAudio, .stProgress, .stExpander > label, .stVegaLiteChart, .stAltairChart, .stPlotlyChart, .stDeckGlJsonChart, .stGraphvizChart, .stTableChart, .stMapboxChart, .stPydeckChart, .stBokehChart, .stPyplot, .stGraphvizChart, .stGraphviz, .stDataFrameSelector, .stFileUploader > label, .stMetric, .stPlotly, .stDeckGl, .stDataFrame, .stArrowVegaLiteChart, .stArrow, .stArrowDataFrame, .stArrowTable, .stArrowChart, .stMetric, .stTabs > label {
            color: #D14524;
        }
        /* Styles for inputs and placeholders */
        input[type="text"], input[type="email"], input[type="password"], input[type="number"], textarea {
            color: #D14524 !important;
        }
        input::placeholder, textarea::placeholder {
            color: #D14524 !important;
        }
        /* Specific styles for labels and select boxes */
        .css-1cpxqw2, .css-1cpxqw2 p, .css-1cpxqw2 h3, .css-1cpxqw2 h4, .css-1cpxqw2 h5, .css-1cpxqw2 h6, .css-1cpxqw2 div, .css-1cpxqw2 span, .css-1cpxqw2 label {
            color: #D14524 !important;
        }
        .css-1l02zno, .css-1l02zno p, .css-1l02zno h3, .css-1l02zno h4, .css-1l02zno h5, .css-1l02zno h6, .css-1l02zno div, .css-1l02zno span, .css-1l02zno label {
            color: #D14524 !important;
        }
        .css-1d391kg p, .css-1d391kg, .css-1d391kg h3, .css-1d391kg h4, .css-1d391kg h5, .css-1d391kg h6, .css-1d391kg div, .css-1d391kg span, .css-1d391kg label {
            color: #D14524 !important;
        }
        .css-1v0mbdj p, .css-1v0mbdj, .css-1v0mbdj h3, .css-1v0mbdj h4, .css-1v0mbdj h5, .css-1v0mbdj h6, .css-1v0mbdj div, .css-1v0mbdj span, .css-1v0mbdj label {
            color: #D14524 !important;
        }
    </style>
    """, 
    unsafe_allow_html=True
)

# Application title
st.title("FALL-ASS")

# Create OpenRouteService client
ors_client = openrouteservice.Client(key='5b3ce3597851110001cf624898e24b3bf3774e8a92088a276b847d49')  # Replace '5b3ce3597851110001cf624898e24b3bf3774e8a92088a276b847d49' with your OpenRouteService key

# Functionality buttons in the sidebar
st.sidebar.header("Select functionality")
if st.sidebar.button("Find Nearest Falla", key="find_falla"):
    st.session_state.section = "Find Nearest Falla"
if st.sidebar.button("Calculate Tourist Route", key="calculate_route"):
    st.session_state.section = "Calculate Tourist Route"

if "section" in st.session_state:
    section = st.session_state.section

    # Find the nearest falla
    if section == "Find Nearest Falla":
        st.header("Find the Nearest Falla")
        address = st.text_input("Enter your address:")
        if st.button("Find", key="find"):
            if address:
                geocoder = OpenCageGeocode('ddf88c4c621e49e4b255ea6e4fc5f23c')  # Replace with your OpenCage API key
                results = geocoder.geocode(address)
                if results:
                    user_location = (results[0]['geometry']['lat'], results[0]['geometry']['lng'])
                    nearest = nearest_falla(data, user_location)
                    st.write(f"The nearest falla is: {nearest['Nom / Nombre']} at {nearest['Direcció / Dirección']}")
                    m = folium.Map(location=user_location, zoom_start=14)
                    folium.Marker(user_location, tooltip="Your Location", icon=folium.Icon(color="blue")).add_to(m)
                    folium.Marker((nearest['geo_point_2d_lat'], nearest['geo_point_2d_lon']), tooltip=nearest['Nom / Nombre'], icon=folium.Icon(color="red")).add_to(m)
                    st_folium(m, width=700, height=500)
                else:
                    st.write("Address not found.")
            else:
                st.write("Please enter your address.")

    # Calculate tourist route
    elif section == "Calculate Tourist Route":
        st.header("Calculate Tourist Route")
        address = st.text_input("Enter your address:")
        max_distance = st.number_input("Maximum distance (in km):", min_value=1.0, max_value=50.0, value=5.0)
        if st.button("Calculate", key="calculate"):
            if address:
                geocoder = OpenCageGeocode('ddf88c4c621e49e4b255ea6e4fc5f23c')  # Replace with your OpenCage API key
                results = geocoder.geocode(address)
                if results:
                    user_location = (results[0]['geometry']['lat'], results[0]['geometry']['lng'])
                    route = calculate_tourist_route(data, user_location, max_distance, ors_client)
                    if not route.empty:
                        st.write(f"Tourist route calculated:")
                        m = folium.Map(location=user_location, zoom_start=14)
                        folium.Marker(user_location, tooltip="Your Location", icon=folium.Icon(color="blue")).add_to(m)
                        coordinates = []
                        for _, falla in route.iterrows():
                            folium.Marker((falla['geo_point_2d_lat'], falla['geo_point_2d_lon']), tooltip=falla['Nom / Nombre'], icon=folium.Icon(color="red")).add_to(m)
                            coordinates.append([falla['geo_point_2d_lon'], falla['geo_point_2d_lat']])
                        route_with_streets = get_route_with_streets(coordinates, ors_client)
                        folium.GeoJson(route_with_streets, name="route").add_to(m)
                        st_folium(m, width=700, height=500)
                    else:
                        st.write("No tourist routes available.")
                else:
                    st.write("Address not found.")
            else:
                st.write("Please enter your address.")

